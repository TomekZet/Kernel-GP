\chapter{Podsumowanie}
W ramach niniejszej pracy stworzono system, który za pomocą programowania genetycznego generuje funkcje jądrowe na potrzeby klasyfikatora \emph{SVM}. System spełnia swe zadanie, czyli znajduje funkcję jądrową, która poprzez użycie jej przez algorytm SVM w tzw. \emph{kernel trick}, przyczynia się do dokonania możliwie dobrej, ze względu na pewną miarę jakości, klasyfikacji zbioru danych.
Algorytm osiąga wyniki porównywalne lub lepsze niż podobne podejścia używające programowania genetycznego.

W trakcie tworzenia pracy przetestowano kilka pomysłów, które nie zostały wykorzystane w ostatecznej wersji algorytmu. Jednym z nich było użycie węzła ,,selekcji'', który dla każdej standardowej funkcji jądrowej użytej w drzewie wybiera podzbiór atrybutów, na którym ona operuje. Operator ten został zaprojektowany jako wektor binarny o długości $ L $, gdzie $ L $ to ilość atrybutów opisujących przypadki w zbiorze danych. Jeśli bit odpowiadający danemu atrybutowi przyjmował wartość 0, to dana funkcja nie korzystała z tego atrybutu. Analiza wyników otrzymanych z użyciem operatora selekcji wykazała, że okazał się on negatywnie wpływać na wyniki klasyfikacji i w toku ewolucji liczebność osobników zawierających ten operator malała z pokolenia na pokolenie.


\section{Napotkane problemy}
Najpoważniejszym problemem napotkanym w trakcie prac nad algorytmem są bardzo długie czasy wykonania, które zmniejszają zakres praktycznych zastosowań algorytmu a także znacząco utrudniają prace nad algorytmem oraz jego testowanie.
Próbą rozwiązania tego problemu może być zrównoleglenie procesu ewolucyjnego. Mechanizmy równoległej oceny osobników są zawarte w bibliotece \emph{ECJ}, ale ich wykorzystanie ma sens tylko w przypadku wykonywania na komputerze posiadającym kilka rdzeni. Przeprowadzone eksperymenty były wykonywane z użyciem pojedynczych wątków w celu zapewnienia powtarzalności wyników, której nie dało się osiągnąć przy użyciu kilku wątków. W zastosowaniach praktycznych, gdzie nie zachodzi potrzeba porównywania parametrów procesu ewolucyjnego i ich wpływu na wyniki klasyfikacji (ponieważ te parametry są już wcześniej znane, a celem jest jedynie znalezienie optymalnej funkcji jądrowej), użycie kilku równoległych wątków do oceny osobników nie wiąże się z żadnymi problemami i może przyspieszyć działanie algorytmu.
Ponadto, w zastosowaniach praktycznych stworzonego systemu długi czas poszukiwania przez algorytm programowania genetycznego funkcji jądrowej może nie stanowić przeszkody - zazwyczaj bardziej istotny jest czas klasyfikacji nowych obiektów, a ten, gdy funkcja jądrowa jest już znaleziona, nie różni się od czasu klasyfikacji przez bibliotekę \emph{LibSVM}.

Bardzo dobre wyniki osiąga prosty i szybki algorytm \emph{grid search} dostarczony z biblioteką \emph{LibSVM}, który jako funkcji jądrowej używa funkcji RBF i manipuluje jedynie dwoma parametrami: stałą $ \gamma $ oraz parametrem $ C $ klasyfikatora SVM. Stworzony algorytm \emph{Kernel GP+} nie manipuluje parametrem $ C $, jego wartość została dobrana eksperymentalnie i użyta dla wszystkich zbiorów i generowanych funkcji. Manipulacja przez proces ewolucyjny tym parametrem mogłaby więc przynieść pozytywne efekty. Stwarza to jednak problemy natury implementacyjnej - parametr $ C $ nie jest częścią funkcji jądrowej i w momencie, kiedy funkcja jądrowa jest ewaluowana powinien już być on znany.

Porównanie wyników osiąganych przez \emph{Kernel GP+} i \emph{grid search} oraz analiza funkcji reprezentowanych przez osobniki ,,wygrywające'' ewolucję kerneli sugeruje, że funkcje jądrowe konstruowane ze zbioru kilku standardowych funkcji jądrowych z użyciem operacji, ze względu na które zbiór kerneli jest zamknięty, nie pozwalają dokonać odmiennych jakościowo mapowań danych do wysoko wymiarowych przestrzeni, w których dane te byłyby łatwiej separowalne, niż przy użyciu pojedynczych standardowych funkcji.

\section{Kierunek dalszych prac}
Dalsze prace nad udoskonaleniem algorytmu mogą obejmować wspomniane powyżej próby zrównoleglenia algorytmu oraz manipulacji parametrem $ C $. Niektóre prace, przytoczone w \ref{sec:evokernel}, sugerują możliwość polepszenia wyników poprzez użycie funkcji przystosowania opartej na bardziej ,,wewnętrznych'' miarach oceny algorytmu, takich jak opisane w części \ref{ssec:alt-meassures}. Warte rozpatrzenia jest również poszerzenie przeszukiwanej przestrzeni funkcji jądrowych, tak, żeby wykroczyć poza te będące jedynie złożeniem kilku funkcji ,,standardowych''.